<!doctype html>
<html lang="en" data-theme="dark">
  <head>
    <meta charset="UTF-8" />
    <title>Document</title>
    <!-- <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.jade.min.css"
    /> -->
    <!-- <link rel="stylesheet" href="../../../libs/pico-main/css/pico.min.css" /> -->
    <link rel="stylesheet" href="../../../libs/pico-main/css/pico.css">
    <link
      rel="stylesheet"
      href="../../../libs/highlight/styles/tomorrow-night-bright.css"
    />
  <link rel="stylesheet" href="../../../styles/styleForPages.css">
  </head>
  <body>
    <div class="container">
      <h1>Начало изучения Golang</h1>
      <a href="#" name="menu"></a>
      <h4>Menu</h4>
      <ul>
        <li><a href="#install">Установка Go настройка VS code</a></li>
        <li><a href="#firstProgram">Первая программа</a></li>
        <li><a href="#variables">Переменные</a></li>
        <li><a href="#dataType">Типы данных</a></li>
        <li><a href="#arrays">Массивы</a></li>
        <li><a href="#ifElseSwitch">if-else-switch</a></li>
        <li><a href="#cycles">Циклы</a></li>
        <li><a href="#study-plan">study-plan</a></li>
        <li><a href="#types">Основные типы в Go</a></li>
        <li><a href="#convert-types">Конвертация типов данных в Go</a></li>
        <li><a href="#flow-and-files">Потоки и файлы</a></li>
        <li>
          <a href="#menu" name="install">menu</a>
      <h4>Установка Golang</h4>
      <ol>
        <li>Заходим на https://go.dev/</li>
        <li>Загружаем установщик для нашей системы</li>
        <li>
          win+r затем набираем cmd затем enter и в командной строке пишим go для
          проверки должны высветится команды для работы с Go
        </li>
      </ol>
      <h4>Настройка VS code</h4>
      <ol>
        <li>Устанавливаем расширение GO</li>
        <li>
          File &rArr; Open folder создаем и/или открываем папку и в этой папке
          создаем файл main.go
        </li>
        <li>
          Заходим в раздел output в терминале и смотрим чтобы все библиотеки
          были установлены об этом скажет строка &rArr; All tools successfully
          installed. You are ready to Go.
        </li>
      </ol>

      <a href="#menu" name="firstProgram">menu</a>

      <h4>Первая программа</h4>
      <p>Программа на языке Go хранится в одном или нескольких файлах. Каждый файл с программным кодом должен принадлежать какому-нибудь пакету.
          Вначале каждого файла должно быть объявление пакета, к которому этот файл принадлежит. Пакет объявляется с помощью ключевого слова package.</p>
         <p>Мы можем  использовать в файле   функционал из других пакетов. Для этого используемые пакеты надо импортировать с помощью ключевого слова import.
           Импортируемые пакеты должны идти после объявления пакета для текущего файла</p>
      <ol>
        <li>Указываем пакет <code>package main</code></li>
        <li>
          Объявляем главную функцию точка входа в программу
          <code>func main(){}</code>
        </li>
        <li>
          Импортируем fmt (если написать fmt и нажать enter) то сработает
          автоимпорт и в верху пропишется строка <code>import "fmt"</code>
        </li>
        <li>В главной функции пишем <code>fmt.Println("Hello world")</code></li>
      </ol>
      <pre><code>
  package main

  import "fmt"
  
  func main() {
    fmt.Println("hello world")
  }    
  
  // - однострочный комментарий
  /* многострочный 
  комментарий*/
        </code></pre>

        <a href="#menu" name="variables">menu</a>

        <h4>Переменные</h4>
        <P> Go - регистрозависимый язык</P>
        <pre>
          <code>
  var newVar int                   //объявление переменной
  var a, b, c string               //Можно одновременно объявить сразу несколько переменных через запятую
  var hello string = "Hello world" //Также можно сразу  присвоить начальное значение. Это называется инициализацией
  var (
    name string = "Tom" //Если мы хотим сразу определить несколько переменных , то можно обернуть их в скобки
    age  int    = 27
  )
  var name, age = "Tom", 27
  name := "Tom" // короткая запись
          </code>
        </pre>

        <a href="#menu" name="dataType">menu</a>

      <h4>Типы данных</h4>
      <h5>числа</h5>
      <ul>
        <li><ul>
          <li>int8: -128 до 127</li>
          <li>int16: -32768 до 32767</li>
          <li>int32: -2147483648 до 2147483647</li>
          <li>int64: –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807</li>
          <li>int: -может быть или  int32, или int64  зависит от платформы</li>
        </ul></li>
        <li><ul>
          <li>uint8: 0 до 255</li>
          <li>uint16: 0 до 65535</li>
          <li>uint32: от 0 до 4294967295</li>
          <li>uint64: от 0 до 18 446 744 073 709 551 615</li>
          <li>uint: -может быть или  uint32, или uint64  зависит от платформы</li>
        </ul></li>
       <li><ul> 
              <li>byte: как uint8</li>
             <li>rune: как int32</li>
        </ul>
       </li>
        <li><ul>
          <li>float32:- 1.4*10-45 до 3.4*1038</li>
          <li>float32:- 4.9*10-324 до 1.8*10308</li>
        </ul></li>
      </ul>
      <h5>Комплексные числа</h5>
      <ul>
        <li>complex64</li>
        <li>complex128</li>
      </ul>
      <h5>Bool</h5>
      <ul>
        <li>true</li>
        <li>false</li>
      </ul>
      <h5>String</h5>
      <ul>
        <li>Строки - заключаются в двойные кавычки и могут иметь специальные символы форматирования \n \r \\ \"</li>
      </ul>
      <p>Если мы объявили переемную и тип но не присвоили значение то значение определится автоматически будет 0 false ""</p>
      <p>Если при инициализации присвоить значение без типа то тип определится автоматически  </p>

      <a href="#menu" name="arrays">menu</a>

        <h4>Массивы</h4>
        <pre><code>
  package main

  import "fmt"
  
  var arr [5]int                          // заполняется нулями по умолчанию [0 0 0 0 0]
  var arr1 [5]int = [5]int{1, 2, 3, 4, 5} //[1 2 3 4 5]
  var arr2 [5]int = [5]int{1, 2}          // нули допишутся [1 2 0 0 0]
  //var arr3 [5]int = [5]int{1, 2, 3, 4, 5, 6} // ошибка нельзя добавить элементов больше длинны
  var arr4 = [...]int{1, 2, 3, 4, 5} // если троеточие то длинна ставится количества переданных  элементов
  
  var arr5 [3]int = [3]int{1, 2, 3}
  var arr6 [4]int = [4]int{1, 2, 3, 4}
  
  var arr7 [3]string = [3]string{2: "blue", 0: "red", 1: "green"} //ключи необязательно располагать в порядке возрастания
  
  func main() {
  
    //arr5 = arr6 // ! Ошибка-- длинна массива это часть его типа поэтому у этих массивов разные типы
    fmt.Println(arr4)
  
  }
          
        </code></pre>
        <a href="#menu" name="ifElseSwitch">menu</a>

        <h4>if-else-switch</h4>
        <pre><code>
          package main

import "fmt"

func main() {

	fmt.Println("arr4")
	if false {

	} else if false {

	} else {

	}
	// switch
	var condition int = 1
	switch condition { //так-же можно использовать выражение 1+1 или condition - 1 итд
	case 1:
		fmt.Println("case 1")
	case 2:
		fmt.Println("case 2")
	default:              //не обязателен 
		fmt.Println("default")
	}
}

        </code></pre>

        <a href="#menu" name="cycles">menu</a>
        <h4>Циклы</h4>
        <pre><code>
          package main

import "fmt"

var i2 int = 1
var i3 int = 1
var colors = [3]string{"red", "blue", "green"}

func main() {
	//первый способ
	for i := 1; i < 10; i++ {
		fmt.Println(i * i)
	}
	//второй способ
	for ; i2 < 10; i2++ {
		fmt.Println(i2)
	}
	//третий способ
	for i3 < 10 {
		fmt.Println(i3)
		i3++
	}
	//вложенный цикл

	for i := 1; i < 10; i++ {
		for j := 1; j < 10; j++ {
			fmt.Print(i*j, "\t")
		}
		fmt.Println()
	}
	// перебор массивов
	for index, value := range colors {
		fmt.Println(index, value)
	}
	// если какое-то значение не нужно то его можно заменить подчеркиванием
	for _, value := range colors {
		fmt.Println(value)
	}
	//классика
	for i := 0; i < len(colors); i++ {
		fmt.Println(colors[i])
	}
	// В циклах также доступны операторы break и continue
}

        </code>
      </pre>
      <a href="#menu" name="types">menu</a>
      <h4>Основные типы в Go</h4>
      <pre>
        <code>
          bool // Boolean, имеет значение True или False
          string // Строки
          int int8  int16  int32  int64 // Целочисленные значения со знаком 
          uint uint8 uint16 uint32 uint64 uintptr // Целочисленные значения без знаков
          byte // alias для uint8
          rune // alias для int32
          float32 float64 // Числа с плавающей точкой
          complex64 complex128 // Комплексные числа
      </code>
    </pre>
        <a href="#menu" name="convert-types">menu</a>
       
        <h4>Конвертация типов данных в Go</h4>
        <h5>Преобразование чисел</h5>
        <p>Чтобы преобразовать int d float Достаточно обернуть переменную конструкцией float64() или float32().</p>
        <p>В примерах можно обойтись и без явного приведения к float. Если вы используете числа с плавающей точкой, то все остальные типы автоматически приводятся к float. <code>a := 5.0 * 2 </code> Но с переменными так работать не будет</p>
        <pre>
          <code>
            func main() {
              var x int64 = 57
              var y float64 = float64(x)
              fmt.Printf("%.2f\n", y)     //число перед f указывает количество знаков после запятой
            }
          </code>
        </pre>
        <h6>Из float в int </h6>
        <pre>
          <code>
            func main() {
              var f float64 = 409.8
              var i int = int(f)  //округление не выполняется все что после запятой отбрасывается
              fmt.Println(i)
            }
          </code>
        </pre>
        <h5>Преобразование строк</h5>
        <p>В Golang число в строку можно преобразовать с помощью метода strconv.Itoa. Он входит в состав пакета strconv стандартной библиотеки языка. <br> синтаксис <code>a := strconv.Itoa(12)</code></p>
        <p>Float к строке <code>test := fmt.Sprint(421.034)</code></p>

        <h5>Строки в число</h5>
        <p> Если строка имеет числовой вид то ее можно преобразовать в число</p>
        <p>Строку в int <code>strconv.Atoi</code></p>
        <p>Строку в Float <code>strconv.ParseFloat</code></p>
        <pre>
          <code>
            func main() {
              lines_yesterday := "50"
              lines_today := "108"
              yesterday, err := strconv.Atoi(lines_yesterday)
              if err != nil {
                log.Fatal(err)
              }
              today, err := strconv.Atoi(lines_today)
              if err != nil {
                log.Fatal(err)
              }
              lines_more := today - yesterday
              fmt.Println(lines_more)
            }
          </code>
        </pre>
        <h5>Строки можно также преобразовывать в срезы байтов и обратно, используя конструкции []byte() и string(). </h5>
        <pre>
          <code>
            func main() {
              a := "timeweb"
              b := []byte(a)
              c := string(b)
              fmt.Println(a)
              fmt.Println(b)
              fmt.Println(c)
            }
          </code>
        </pre>
        <a href="#menu" name="flow-and-files">menu</a>
        <h2>Потоки и файлы</h2>
        <h4>Чтение и запись</h4>
        <pre>
          <code>
                          Интерфейсы 
                          Чтение
            type Reader interface { 
              Read(p []byte) (n int, err error) 

                            Запись
            type Writer interface { 
              Write(p []byte) (n int, err error) 
          }

          }                
          </code>
        </pre>
        <h4>Создание и открытие файлов</h4>
        <p>С помощью функции os.Create() можно создать файл по определенному пути. Путь к файлу передается в качестве параметра. Если подобный файл уже существует, то он перезаписывается:</p>
        <pre>
          <code>
            file, err := os.Create("hello.txt")
            Функция возвращает объект os.File для работы с файлом и информацию об ошибке, которая может возникнуть при создании файла.

            Созданный файл можно открыть с помощью функции os.Open()

            file, err := os.Open("hello.txt")

            Эта функция также возвращает объект os.File для работы с файлом и 
            информацию об ошибке, которая может возникнуть при открытии файла.

            os.OpenFile() - открывает файл, а если файла нет, то создает его.
            Она принимает три параметра:
            1) путь к файлу
            2) режим открытия файла (для чтения, для записи и т.д.)
            3) разрешения для доступа к файлу
            Пример:
            // открытие файла для чтения
            f1, err := os.OpenFile("sometext.txt", os.O_RDONLY, 0666) 
            // открытие файла для записи
            f2, err := os.OpenFile("common.txt", os.O_WRONLY, 0666)

            После окончания работы с файлом его следует закрыть с помощью метода Close().
            defer file.Close() 

            С помощью функции os.Exit() можно выйти из программы.
            А метод Name(), определенный для типа os.File, позволяет получить имя файла.
          </code>
        </pre>
    </div>

    <script src="../../../libs/highlight/highlight.pack.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
  </body>
</html>
