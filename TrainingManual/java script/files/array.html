<!doctype html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>Методичка arr</title>
    <link rel="stylesheet" href="../../css/index.css" />
    <link
      rel="stylesheet"
      href="../../libs/highlight/styles/atom-one-dark-reasonable.css"
    />
  </head>
  <body>
    <div class="wrapper">
      <h2>Массивы</h2>
      <ul>
        <li><a href="#hint">Шпаргалка</a></li>
        <li><a href="#one">Объявление массивов</a></li>
        <li>
          <a href="#push">push pop shift unshift - </a>добавляют/удоляют
          элементы
        </li>
        <li>
          <a href="#for"
            >Перебор элементов Многомерные массивы Метод toString</a
          >
        </li>
        <li><a href="#splice">Splice Slice Concat</a></li>
        <li><a href="#forEach">forEach</a></li>
        <li><a href="#indexOf">indexOf lastIndexOf includes</a></li>
        <li><a href="#find">find и findIndex</a></li>
        <li><a href="#filter">filter</a></li>
        <li><a href="#map">map</a></li>
        <li><a href="#sort">sort</a></li>
        <li><a href="#reverse">reverse</a></li>
        <li><a href="#split">split и join</a></li>
        <li><a href="#reduce">arr.reduce и arr.reduceRight</a></li>
        <li><a href="#Array">Array.isArray Array.from()</a></li>
      </ul>
      <a name="one" href="#top">top</a>
      <h3>Объявление массивов</h3>
      <pre>
        <code class="js">
    # Ваш Код
    let arr = new Array();
    let arr1 = new Array(5);// создаст массив с длинной равной (5)

    let arr = [];                                                             # этот вариант используется чаще

    let fruits = ["Яблоко", "Апельсин", "Слива"];

    alert( fruits[0] ); // Яблоко
    alert( fruits[1] ); // Апельсин
    alert( fruits[2] ); // Слива

    fruits[2] = 'Груша'; // теперь ["Яблоко", "Апельсин", "Груша"]            # заменили элемент
    fruits[3] = 'Лимон'; // теперь ["Яблоко", "Апельсин", "Груша", "Лимон"]   # добавили новый элемент

    fruits.length //4                                                         # Общее число элементов массива

    alert( fruits ); // Яблоко, Апельсин, Груша, Лимон                         Выводит весь массив целиком

                            В массиве могут храниться элементы любого типа.
    
    // разные типы значений
    let arr = [ 'Яблоко', { name: 'Джон' }, true, function() { alert('привет'); } ];
    
    // получить элемент с индексом 1 (объект) и затем показать его свойство
    alert( arr[1].name ); // Джон
    
    // получить элемент с индексом 3 (функция) и выполнить её
    arr[3](); // привет
        </code>
    </pre>
      <a name="push" href="#top">top</a>
      <h3>Методы pop/push, shift/unshift</h3>

      <pre>
        <code class="js">
    shift   //удаляет элемент в начале
    unshift //Добовляет элемент в начало

    push    //добавляет элемент в конец.
    pop     //удаляет последний элемент.

    fruits.unshift('Яблоко'); //добавили элемент в начало
    fruits.unshift("Ананас", "Лимон"); //можно добовлять несколько элементов в начало
    alert( fruits.shift() ); // удаляем 1 элемент и выводим его

    pop,push // делают тоже самое с хвоста

        </code>
    </pre>
      <a name="for" href="#top">top</a>
      <h3>Перебор элементов Многомерные массивы Метод toString</h3>
      <pre>
        <code class="js">
                                    цикл for по цифровым индексам

    for (let i = 0; i < arr.length; i++) {
        alert( arr[i] );
        }

                                        Цикл for..of

    for (let fruit of fruits) {
    alert( fruit );
    }
    //Цикл for..of не предоставляет доступа к номеру текущего элемента, только к его значению

    //   Цикл for..in  НЕ ИСПОЛЬЗЩВАТЬ при переборе массива

    
    arr.length == наибольший цифровой индекс плюс один.
    arr.length = 0; // способ обнулить массив

    //********************************* Многомерные массивы**********************************************************

    Массивы могут содержать элементы, которые тоже являются массивами.

    let matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
    ];

    alert( matrix[1][1] ); // 5, центральный элемент

    //***************************************** toString ***************************************************

    Массивы по-своему реализуют метод toString, который возвращает список элементов, разделённых запятыми.

    let arr = [1, 2, 3];

    alert( arr ); // 1,2,3
    alert( String(arr) === '1,2,3' ); // true
        </code>
    </pre>

      <a name="splice" href="#top">top</a>
      <h3>Splice Slice Concat</h3>
      <pre>
<code class="js">
    arr.splice(index[, deleteCount, elem1, ..., elemN])

    Начиная с позиции index,
    удаляет deleteCount элементов и вставляет elem1, ..., elemN на их место.
    Возвращает массив из удалённых элементов.

    arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент
    arr.splice(0, 3, "Давай", "танцевать");// удалить 3 первых элемента и заменить их другими
    let removed = arr.splice(0, 2);// удаляет 2 первых элемента и варачивает 
    arr.splice(2, 0, "сложный", "язык"); //вставляет элементы без удаления

    //******************************************* slice ************************************

    arr.slice([start], [end])
    Он возвращает новый массив, в который копирует элементы,
    начиная с индекса start и до end (не включая end). 
    Оба индекса start и end могут быть отрицательными.
    В таком случае отсчёт будет осуществляться с конца массива.

    let arr = ["t", "e", "s", "t"];
    alert( arr.slice(1, 3) ); // e,s (копирует с 1 до 3)

    Можно вызвать slice и вообще без аргументов: arr.slice() создаёт КОПИЮ массива arr.

    //********************************************** concat *****************************
    Метод arr.concat создаёт новый массив, в который копирует данные из других массивов и 
    дополнительные значения.

    arr.concat(arg1, arg2...)//мы получаем новый массив, включающий в себя элементы из arr, а также arg1, arg2 и так далее…
    let arr = [1, 2];
    alert( arr.concat([3, 4]) ); // 1,2,3,4
    alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6
    alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6
</code>
</pre>
      <a name="forEach" href="#top">top</a>
      <h3>forEach</h3>
      <pre>
    <code class="js">
    Метод arr.forEach позволяет запускать функцию для каждого элемента массива.
    ["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
        alert(`${item} имеет позицию ${index} в ${array}`);
      });
    </code>
</pre>
      <a name="indexOf" href="#top">top</a>
      <h3>indexOf lastIndexOf includes</h3>
      <pre>
    <code class="js">
    Методы arr.indexOf, arr.lastIndexOf и arr.includes имеют одинаковый синтаксис и делают по сути то же самое,
    что и их строковые аналоги, но работают с элементами вместо символов:

    arr.indexOf(item, from) ищет item, начиная с индекса from, и возвращает индекс, на котором был найден искомый элемент, в противном случае -1.
    arr.lastIndexOf(item, from) – то же самое, но ищет справа налево.
    arr.includes(item, from) – ищет item, начиная с индекса from, и возвращает true, если поиск успешен.
    includes правильно обрабатывает NaN в отличие от indexOf/lastIndexOf
    </code>
</pre>
      <a name="find" href="#top">top</a>
      <h3>find и findIndex</h3>
      <pre>
    <code>
    let result = arr.find(function(item, index, array) {
        });
    Функция вызывается по очереди для каждого элемента массива:

    item – очередной элемент.
    index – его индекс.
    array – сам массив.
    Если функция возвращает true, поиск прерывается и возвращается item. 
    Если ничего не найдено, возвращается undefined.

    let users = [
    {id: 1, name: "Вася"},
    {id: 2, name: "Петя"},
    {id: 3, name: "Маша"}
    ];

    let user = users.find(item => item.id == 1);
    alert(user.name); // Вася
    В основном используется item другие аргументы используются редко

    Метод arr.findIndex – по сути, то же самое, но возвращает индекс, на котором был найден элемент, а не сам элемент, и -1, если ничего не найдено.
    </code>
</pre>
      <a name="filter" href="#top">top</a>
      <h3>filter</h3>
      <pre>
    <code class="js">
    filter возвращает массив из всех подходящих элементов:

    let results = arr.filter(function(item, index, array) {
        // если true - элемент добавляется к результату, и перебор продолжается
        // возвращается пустой массив в случае, если ничего не найдено
      });

      let users = [
  {id: 1, name: "Вася"},
  {id: 2, name: "Петя"},
  {id: 3, name: "Маша"}
];

// возвращает массив, состоящий из двух первых пользователей
let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2
    </code>
</pre>
      <a name="map" href="#top">top</a>
      <h3>map</h3>
      <pre>
    <code class="js">
    Метод arr.map является одним из наиболее полезных и часто используемых.

    Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.

    let result = arr.map(function(item, index, array) {
        // возвращается новое значение вместо элемента
        });

        let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
    alert(lengths); // 5,7,6  преобразуем каждый элемент в его длину:
    </code>
</pre>
      <a name="sort" href="#top">top</a>
      <h3>sort</h3>
      <pre>
    <code class="js">
    Вызов arr.sort() сортирует массив на месте, меняя в нём порядок элементов.

    Он возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, так как изменяется сам arr.

    let arr = [ 1, 2, 15 ];

    // метод сортирует содержимое arr
    arr.sort();

    alert( arr );  // 1, 15, 2 По умолчанию элементы сортируются как строки.

    Чтобы использовать наш собственный порядок сортировки, нам нужно предоставить функцию в качестве аргумента arr.sort().
    function compare(a, b) {
        if (a > b) return 1; // если первое значение больше второго
        if (a == b) return 0; // если равны
        if (a < b) return -1; // если первое значение меньше второго
      }
      или коротко: arr.sort( (a, b) => a - b ); 
    </code>
</pre>
      <a name="reverse" href="#top">top</a>
      <h3>reverse</h3>
      <pre>
    <code class="js">
    Метод arr.reverse меняет порядок элементов в arr на обратный.

    let arr = [1, 2, 3, 4, 5];
    arr.reverse();

    alert( arr ); // 5,4,3,2,1
    Он также возвращает массив arr с изменённым порядком элементов.
    </code>
</pre>
      <a name="split" href="#top">top</a>
      <h3>split и join</h3>
      <pre>
    <code class="js">
    str.split(delim) разбивает строку на массив по заданному разделителю delim.

    У метода split есть необязательный второй числовой аргумент – ограничение на количество элементов в массиве.

    let arr = 'Вася, Петя, Маша, Саша'.split(', ', 2);
    alert(arr); // Вася, Петя

    str.split('') // рзбивает строку на массив букв

    //************************************* join **************************************

    arr.join(glue)   создаёт строку из элементов arr, вставляя glue между ними.

    let arr = ['Вася', 'Петя', 'Маша'];
    let str = arr.join(';'); // объединить массив в строку через ;
    alert( str ); // Вася;Петя;Маша

    </code>
</pre>
      <a name="reduce" href="#top">top</a>
      <h3>arr.reduce и arr.reduceRight</h3>
      <pre>
    <code class="js">
    arr.reduce и arr.reduceRight используются для вычисления какого-нибудь единого значения на основе всего массива.

    let value = arr.reduce(function(previousValue, item, index, array) {
        // ...
      }, [initial]);

    Функция применяется по очереди ко всем элементам массива и «переносит» свой результат на следующий вызов.

    Аргументы:
    previousValue – результат предыдущего вызова этой функции, равен initial при первом вызове (если передан initial),
    item – очередной элемент массива,
    index – его индекс,
    array – сам массив.

    let arr = [1, 2, 3, 4, 5];

    let result = arr.reduce((sum, current) => sum + current, 0);

    alert(result); // 15

    Здесь мы использовали наиболее распространённый вариант reduce, который использует только 2 аргумента.

    Давайте детальнее разберём, как он работает.

    При первом запуске sum равен initial (последний аргумент reduce), то есть 0, а current – первый элемент массива, равный 1.
     Таким образом, результат функции равен 1.
    При втором запуске sum = 1, и к нему мы добавляем второй элемент массива (2).
    При третьем запуске sum = 3, к которому мы добавляем следующий элемент, и так далее…

    Метод arr.reduceRight работает аналогично, но проходит по массиву справа налево.
    </code>
</pre>
      <a name="Array" href="#top">top</a>
      <h3>Array.isArray Array.from()</h3>
      <pre>
    <code class="js">
    typeof не может отличить простой объект от массива:
    Array.isArray  может отличить простой объект от массива:
    alert(typeof {}); // object
    alert(typeof []); // тоже object

    Array.isArray(value) возвращает true, если value массив, и false, если нет.

    alert(Array.isArray({})); // false
    alert(Array.isArray([])); // true

    Array.from() позволяет вам создавать массивы из:
    массивоподобных объектов (объектов со свойством length и элементами по индексным ключам) или
    итерируемых объектов (объектов, из которых вы можете достать их элементы, например Map или Set).
    
    ПРИМЕР: let keys = [];
            for(let key of map.keys()  ){
            keys.push(key);
            с Array.from код короче
            let keys = Array.from(map.keys());
    </code>
</pre>
      <a href="#top" name="hint">top</a>
      <h3>Шпаргалка по массивам</h3>
      <pre>
    <code class="js">
        Для добавления/удаления элементов:

        push (...items) – добавляет элементы в конец,
        pop() – извлекает элемент с конца,
        shift() – извлекает элемент с начала,
        unshift(...items) – добавляет элементы в начало.
        splice(pos, deleteCount, ...items) – начиная с индекса pos, удаляет deleteCount элементов и вставляет items.
        slice(start, end) – создаёт новый массив, копируя в него элементы с позиции start до end (не включая end).
        concat(...items) – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. Если какой-то из items является массивом, тогда берутся его элементы.
        Для поиска среди элементов:
        
        indexOf/lastIndexOf(item, pos) – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.
        includes(value) – возвращает true, если в массиве имеется элемент value, в противном случае false.
        find/filter(func) – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается true.
        findIndex похож на find, но возвращает индекс вместо значения.
        Для перебора элементов:
        
        forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.
        Для преобразования массива:
        
        map(func) – создаёт новый массив из результатов вызова func для каждого элемента.
        sort(func) – сортирует массив «на месте», а потом возвращает его.
        reverse() – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
        split/join – преобразует строку в массив и обратно.
        reduce(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.
        Дополнительно:
        
        Array.isArray(arr) проверяет, является ли arr массивом.
        Обратите внимание, что методы sort, reverse и splice изменяют исходный массив.
        
        Изученных нами методов достаточно в 99% случаев, но существуют и другие.
        
        arr.some(fn)/arr.every(fn) проверяет массив.
        
        Функция fn вызывается для каждого элемента массива аналогично map. Если какие-либо/все результаты вызовов являются true, то метод возвращает true, иначе false.
        
        arr.fill(value, start, end) – заполняет массив повторяющимися value, начиная с индекса start до end.
        
        arr.copyWithin(target, start, end) – копирует свои элементы, начиная со start и заканчивая end, в собственную позицию target (перезаписывает существующие).
        
        Полный список есть в справочнике MDN.
        
        На первый взгляд может показаться, что существует очень много разных методов, которые довольно сложно запомнить. Но это гораздо проще, чем кажется.
        
        Внимательно изучите шпаргалку, представленную выше, а затем, чтобы попрактиковаться, решите задачи, предложенные в данной главе. Так вы получите необходимый опыт в правильном использовании методов массива.
        
        Всякий раз, когда вам будет необходимо что-то сделать с массивом, а вы не знаете, как это сделать – приходите сюда, смотрите на таблицу и ищите правильный метод. Примеры помогут вам всё сделать правильно, и вскоре вы быстро запомните методы без особых усилий.
    </code>
</pre>
    </div>
    <script src="../../libs/highlight/highlight.pack.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
  </body>
</html>
